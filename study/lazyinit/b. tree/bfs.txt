"""

# 설명 (알고리즘)
 - Breadth First Search
 - 너비 우선 탐색은 트리나 그래프를 방문 또는 탐색하는 방법이다. 탐색 방법은 다음과 같다.

1. 루트에서 시작한다.
2. 자식 노드들을 [1]에 저장한다.[1]
3. [1]에 저장된 노드들을 차례로 방문한다. 또한 각각의 자식들을 [2]에 저장한다.
4. [2]에 저장된 노드들을 차례로 방문한다. 또한 각각의 자식들을 [3]에 저장한다.
5. 위의 과정을 반복한다.
6. 모든 노드를 방문하면 탐색을 마친다.

# point
- 큐를 써서 구현한다. 각 경우를 검사하면서 발생하는 새로운 경우를 큐에 집어넣고, 검사한 원소는 큐에서 뺀다. BFS 의 장점은 DFS 가 못 건드리는 문제(부모와 자식의 상태가 같은 경우가 존재할 때)를 풀 수 있는 것이지만, 공간 복잡도가 지수 스케일로 폭발하기 때문에 가지치기를 제대로 안하면 DFS보다 빨리 오버플로우에 다다를 수 있다.
- DFS 와의 가장 큰 차이로, 여러 갈래 중 무한한 길이를 가지는 경로가 존재하고 탐색 목표가 다른 경로에 존재하는 경우 DFS로 탐색할 시에는 무한한 길이의 경로에서 영원히 종료하지 못하지만, BFS의 경우는 모든 경로를 동시에 진행하기 때문에 탐색이 가능하다는 특징이 있다.
- 모든 경우의 수를 고려해야 하는 경우에 BFS로 구현하는 경우 공간복잡도가 커진다.
- 최소 횟수, 최단 거리 등 문제에 효율적이다.

- Breadth First Search : 너비 우선 탐색에서 개선된 방식
  > Greedy 알고리즘으로 해결가능한 문제인 경우 상대적으로 효율적이다.

- Greedy 알고리즘 : 최적해를 구하는 데에 사용되는 근사적인 방법으로, 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달하는 알고리즘
  > Greedy 은 Optimal Substructure 를 만족하여야 최적의 해를 구할 수 있고 이 역시 언제나 최적의 해를 구할 수는 없다.
  > Greedy 알고리즘이 최적의 해를 구할 수 있으려면 문제가 매트로이드 구조여야 한다. -> 추후 찾아볼 것
  > 매트로이드는 모든 문제에서 나타나는 것은 아니나, 여러 곳에서 발견되기 때문에 탐욕 알고리즘의 활용도를 높여 준다.

- Optimal Substructure : 최적해가 부분문제에 대해서도 역시 최적해. ex) 최단 경로 거리
  > (참고) 추후 배울 Dynamic Programming 으로 문제를 해결할 때 필요한 조건이다.

"""